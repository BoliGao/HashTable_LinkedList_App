Before releasing any amount of code, developers usually test their work to tune performance and prove that the software works as intended. But often, validation is quite difficult, even if the application is simple.

For example, the venerable Unix/Linux ls utility is conceptually quite simple, yet its many options and the myriad vagaries of the underlying file system make validating ls quite a challenge.

To help validate the operation of their code, developers often rely on test suites to either simulate or recreate operational scenarios. If the test suite is thorough, all of the features of the code can be exercised and be shown to work.

But how thorough is thorough? In theory, a completely thorough test suite would test all circumstances, validate all of the results, and exercise every single line of code, demonstrating that no code is "dead." (As Stephen Friedl pointed out in last month's column, dead code is a favorite hiding place for pesky bugs.) Validating results can be done in any number of ways since output is typically tangible in one form or another, but how do you make sure that all of your code was executed? Use GNU's gcov.

Like an X-ray machine, gcov peers into your code and reports on its inner workings. And gcov is easy to use: simply compile your code with gcc and two extra options, and your code will automatically generate data that highlights statement-by-statement, run-time coverage. Best of all, gcov is readily available: if you have gcc installed, you also have gcov-- gcov is a standard part of the GNU development tools.

This month, let's look at code coverage analysis and how to use gcov to help improve the quality of your code and the quality and thoroughness of your test suites.

What is Code Coverage Analysis?

As mentioned above, it's ideal to find dead code and get rid of it. In some cases, it may be appropriate to remove dead code because it's unneeded or obsolete. In other cases, the test suite itself may have to be expanded to be more thorough. Code coverage analysis is the (often iterative) process of finding and targeting "dead" or unexercised code, and is characterized by the following steps:

1. Find the areas of a program not exercised by the test suite.

2. Create additional test cases to exercise the dead code, thereby increasing code coverage.

3. Determine a quantitative measure of code coverage, which is an indirect measure of quality.

Code coverage analysis is also useful to identify which test cases are appropriate to run when changes are made to a program and to identify which test cases do not increase coverage.